/*
 * generated by Xtext
 */
package es.unican.lavoisier.generator

import es.unican.lavoisier.domainModelProvider.DomainModelProvider
import es.unican.lavoisier.lavoisier.AttributeFilter
import es.unican.lavoisier.lavoisier.LavoisierFactory
import es.unican.lavoisier.lavoisier.Projection
import es.unican.lavoisier.lavoisier.ProjectionElements
import java.lang.reflect.Method
import java.util.ArrayList
import java.util.Collections
import java.util.HashSet
import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LavoisierGenerator implements IGenerator {

  private EPackage domainModel
  private Resource domainInstanceResource

  private boolean verbose = false;

  new() {
    super()
    DomainModelProvider.init()
  }

  override void doGenerate(Resource resource, IFileSystemAccess fsa) {
    val projections = resource.getContents().get(0) as ProjectionElements
    // Reload domain metamodel and model if changes are present
    DomainModelProvider::loadDomainModelResources(resource.resourceSet,
                             projections.domainModelNSURI,
                             projections.domainModelInstance);
    domainModel = DomainModelProvider::domainModel
    domainInstanceResource = DomainModelProvider::domainInstanceResource
    // Projections model file (debugging and verbose purposes)
    if (verbose) {
      val fileUri = resource.URI;
      val modelName = fileUri.trimFileExtension().lastSegment();
      val modelUri= fileUri.trimSegments(1).appendSegment(modelName + ".model");
      val modelResource = resource.getResourceSet().createResource(modelUri);
      modelResource.getContents().add(projections);
      modelResource.save(Collections.EMPTY_MAP);
    }
    // Generating a csv file for each dataset/projection declared
    for (projection: projections.projections) {
      createTabularData(projection, fsa)
    }
  }

  def void createTabularData(Projection projection, IFileSystemAccess fsa) {
    // csv creation
    val dataFileContent = new StringBuilder()
    includeColumnNames(projection, dataFileContent)
    includeElementData(projection, dataFileContent)
    // saving the data
    val dataFileName = projection.name + ".csv"
    fsa.generateFile(dataFileName, dataFileContent)
  }

  def HashSet<String> obtainColumnPrefixes(EClass eClass,
      String referredObjectId) {
    val referredEAttribute =
          eClass.getEStructuralFeature(referredObjectId) as EAttribute
    // we need every different value of this attribute to make
    //   columns out of them
    val refEClassElements = domainInstanceResource.allContents.filter[
      element | element.eClass.name.equals(eClass.name)]
    // set to store different values (each one will become a column)
    val columnPrefixes = new HashSet<String>()
    for (element : refEClassElements.toIterable) {
      val prefix = element.eGet(referredEAttribute)
      columnPrefixes.add(prefix as String)
    }
    return columnPrefixes
  }


  def List<String> filterAttributes(EList<EAttribute> attributes,
                                    AttributeFilter filter) {
    var List<String> filteredAttributes = null
    if (filter != null) {
      filteredAttributes = filter.attributes
    } else {
      filteredAttributes =
          attributes.map[attr | attr.name]
    }
    return filteredAttributes
  }


  def List<EAttribute> filterEAttributes(EList<EAttribute> attributes,
                                         AttributeFilter filter) {
    var List<EAttribute> filteredEAttributes = null
    if (filter == null) {
      filteredEAttributes = attributes
    } else {
      filteredEAttributes =
          attributes.filter[attr | filter.attributes.contains(attr.name)].toList
    }
    return filteredEAttributes
  }


  def prefixAttributes(List<String> attributes, String prefix) {
    return attributes.map[attr | prefix + attr]
  }

  def List<EClass> getSubClasses(EClass superClass) {
    val subClasses = new ArrayList<EClass>
    for (element : domainModel.EClassifiers) {
      if (element instanceof EClass &&
          !element.equals(superClass) &&
          superClass.isSuperTypeOf(element as EClass)) {
        subClasses.add(element as EClass)
      }
    }
    return subClasses
  }


  def AttributeFilter prepareAttributeFilter(AttributeFilter filter, EClass eClass,
        String referredObjectId) {
    var resFilter = filter
    if (resFilter == null) {
      // create it to hold every attribute but the referred id attribute
      val eFactory = LavoisierFactory.eINSTANCE
      resFilter = eFactory.createAttributeFilter
      for (attribute : eClass.EAttributes) {
        resFilter.attributes.add(attribute.name)
      }
    }
    resFilter.attributes.remove(referredObjectId)
    return resFilter
  }


  def private void includeColumnNames(Projection projection,
      StringBuilder dataFileContent) {
    val mainEClass =
        domainModel.getEClassifier(projection.mainClass.name) as EClass
    // main class attributes
    val filteredAttributes =
        filterAttributes(mainEClass.EAllAttributes,
                         projection.mainClass.attributeFilter)

    dataFileContent.append(String.join(",", filteredAttributes))
    // reference features names
    for (refClass : projection.referredClasses) {
      val refEClass = domainModel.getEClassifier(refClass.name) as EClass
      val reference =
        mainEClass.getEStructuralFeature(refClass.reference) as EReference
      if (reference.upperBound == 1) {
        // reference class and superclasses attributes
        var List<String> refAttributes =
          filterAttributes(refEClass.EAllAttributes,
          refClass.attributeFilter)
          val prefix = refClass.reference + "_"
          refAttributes = prefixAttributes(refAttributes, prefix)
          dataFileContent.append("," + String.join(",", refAttributes))
        if (refEClass.isAbstract()) {
          // Include subclass attributes
          val subClasses = getSubClasses(refEClass)
          for(subClass : subClasses) {
            val sprefix = refClass.reference + "_" + "sub_" + subClass.name + "_"
            val sAttributes = prefixAttributes(
              subClass.EAttributes.map[attr | attr.name], sprefix)
            dataFileContent.append("," + String.join(",", sAttributes))
          }
          // the type will indicate the subclass of the instance
          dataFileContent.append(",type")
        }
      } else {
        // A set of columns is added for each possible value
        //   of the attribute which acts as id
        val referredObjectId = refClass.referredObjectId
        val columnPrefixes = obtainColumnPrefixes(refEClass, referredObjectId)
        var filter = prepareAttributeFilter(refClass.attributeFilter,
          refEClass, referredObjectId)
        for (prefix : columnPrefixes.sort) {
          val refAttributes = prefixAttributes(filter.attributes,
                                               prefix + "_")
          dataFileContent.append("," + String.join(",", refAttributes))
        }
      }
    }
    dataFileContent.append("\n")
  }


  /**
   * Include data of each element into the dataset
   * @param columnNames Indicates the order of appereance of each attribute
   */
  def private void includeElementData(Projection projection,
                                      StringBuilder dataFileContent) {
    val mainEClass =
        domainModel.getEClassifier(projection.mainClass.name) as EClass
    val mainEClassElements = domainInstanceResource.allContents.filter[
      element | element.eClass.name.equals(projection.mainClass.name)]
    for (element : mainEClassElements.toIterable) {
      // basic attributes values
      dataFileContent.append(
          String.join(",",
                      filterEAttributes(element.eClass.EAllAttributes,
                                        projection.mainClass.attributeFilter)
                      .map(attr | element.eGet(attr).toString)))
      // referred features values
      for (refClass : projection.referredClasses) {
        val refEClass = domainModel.getEClassifier(refClass.name) as EClass
        val reference =
          mainEClass.getEStructuralFeature(refClass.reference) as EReference
        if (reference.upperBound == 1) {
          val attributeValues = new ArrayList<String>()
          val refObject = element.eGet(reference)
          if (refObject != null) {
            val objectClass = refEClass.instanceClass
            val filteredEAttributes = filterEAttributes(refEClass.EAllAttributes,
                                        refClass.attributeFilter)
            for (attribute : filteredEAttributes) {
              // attribute value obtention through emf interface getter method
              //   reflection required
              val Method method = objectClass.getDeclaredMethod(
                  "get" + attribute.name.toFirstUpper)
              val value = method.invoke(refObject)
              attributeValues.add(value.toString)
            }
            if (refEClass.isAbstract) {
              var type = refEClass.name
              // we won't have values for each subclass
              // When not the instance type, add blank fields
              for (subClass : getSubClasses(refEClass)) {
                if (subClass.isInstance(refObject)) {
                  for (attribute : subClass.EAttributes) {
                    val Method method = subClass.instanceClass.getDeclaredMethod(
                        "get" + attribute.name.toFirstUpper)
                    val value = method.invoke(refObject)
                    attributeValues.add(value.toString)
                  }
                  // get the concrete type of the instance
                  type = subClass.name
                } else {
                  // blank cell
                  for (attribute : subClass.EAttributes) {
                    attributeValues.add("")
                  }
                }
              }
              // Finally, the type attribute
              attributeValues.add(type)
            }
          } else {
            // add as much missing values as attributes would've been included
            for (attribute : refEClass.EAllAttributes) {
              attributeValues.add("")
            }
            for (subClass : getSubClasses(refEClass)) {
              for (attribute : subClass.EAttributes) {
                attributeValues.add("")
              }
            }
          }
          dataFileContent.append("," + String.join(",", attributeValues))
        } else {
          // this only works if no nulls are present (TODO: fix this)
          val objectClass = refEClass.instanceClass
          val referredObjectId = refClass.referredObjectId
          val Method referredObjectIdMethod = objectClass.getDeclaredMethod(
                  "get" + referredObjectId.toFirstUpper)
          var refList = element.eGet(reference) as List<Object>
          refList.sortInplaceBy[refEl |
                                referredObjectIdMethod.invoke(refEl) as String]
          var filter = prepareAttributeFilter(refClass.attributeFilter,
              refEClass, referredObjectId)
          for (refElement : refList) {
            val attributeValues = new ArrayList<String>()
            for (attributeName : filter.attributes) {
              // attribute value obtention through emf interface getter method
              //   reflection required
              val Method method = objectClass.getDeclaredMethod(
                  "get" + attributeName.toFirstUpper)
              val value = method.invoke(refElement)
              attributeValues.add(value.toString)
            }
            dataFileContent.append("," + String.join(",", attributeValues))
           }
        }
      }
      dataFileContent.append("\n")
    }
  }
}
